#+title: DOOM Emacs Config
#+STARTUP: overview
#+PROPERTY: header-args:emacs-lisp :tangle yes :cache yes :results silent

* Table of Contents :toc:
- [[#about-this-config][About this Config]]
- [[#basics][Basics]]
  - [[#sensible-defaults][Sensible Defaults]]
  - [[#emacs-everywhere][Emacs EVERYWHERE]]
- [[#appearance][Appearance]]
  - [[#fonts][Fonts]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#dashboard-startup-page][Dashboard (startup page)]]
  - [[#line-numbers-and-wrapping][Line Numbers and Wrapping]]
  - [[#transparent-background][Transparent Background]]
  - [[#whitespace][Whitespace]]
  - [[#treemacs][Treemacs]]
- [[#global-functionality][Global Functionality]]
  - [[#local-leader][Local Leader]]
  - [[#movecut][Move/Cut]]
  - [[#auto-complete][Auto-complete]]
  - [[#spell--and-grammar-checker][Spell- and grammar checker]]
  - [[#snippets][Snippets]]
  - [[#zenwriteroom][Zen/Writeroom]]
- [[#org-mode][Org Mode]]
  - [[#org-paths][Org-Paths]]
  - [[#org-appearance][Org Appearance]]
  - [[#org-roam][Org Roam]]
  - [[#latex--org][LaTeX & Org]]
  - [[#xournal-integration-org-notebook][Xournal++ integration ("Org Notebook")]]
  - [[#org-d20][org-d20]]
- [[#latex][LaTeX]]
  - [[#fixing-defaults]["Fixing" defaults]]
  - [[#appearance-1][Appearance]]
  - [[#cdlatex][CDLaTeX]]
- [[#tangle-this-file][Tangle this file!]]

* About this Config
Here is some help from the default config.el that I haven't found a better spot for yet.
#+begin_quote
Here are some additional functions/macros that could help you configure Doom:

- `load!' for loading external *.el files relative to this one
- `use-package!' for configuring packages
- `after!' for running code after a package has loaded
- `add-load-path!' for adding directories to the `load-path', relative to
  this file. Emacs searches the `load-path' when you load packages with
  `require' or `use-package'.
- `map!' for binding new keys

To get information about any of these functions/macros, move the cursor over
the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
This will open documentation for it, including demos of how they are used.

You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
they are implemented.
#+end_quote


* Basics

#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

(setq user-full-name "Michael Reitmeir"
      user-mail-address "michi.reitmeir@gmail.com")
#+end_src

** Sensible Defaults
Inspired by [[https://tecosaur.github.io/emacs-config/config.html#better-defaults][tecosaur]], who was in turn inspired by others. Funny how that works.
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")
#+end_src

Tecosaur finds it handy to be asked which buffer to see after splitting a window. So do I.
#+begin_src emacs-lisp
;; first, enter the new window
(setq evil-vsplit-window-right t
      evil-split-window-below t)
;; then, pull up buffer prompt
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src
** Emacs EVERYWHERE
This changes the name of windows created with ~emacs-everwhere~, so that I can more easily customize their behaviour in my window manager.
#+begin_src emacs-lisp :tangle yes
(setq emacs-everywhere-frame-name-format "emacs-everywhere")
#+end_src
Specifically, I want my window manager to handle it's position rather than emacs.
#+begin_src emacs-lisp :tangle yes
(remove-hook 'emacs-everywhere-init-hooks #'emacs-everywhere-set-frame-position)
#+end_src
Org mode is nice.
#+begin_src emacs-lisp :tangle yes
(setq emacs-everywhere-major-mode-function #'org-mode)
#+end_src

* Appearance
** Fonts
From the default config.el:
#+begin_quote
Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ `doom-font'
+ `doom-variable-pitch-font'
+ `doom-big-font' -- used for `doom-big-font-mode'; use this for
  presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need these two:
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_quote

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrains Mono" :size 15 :weight 'regular)
      doom-variable-pitch-font (font-spec :family "Libertinus Sans" :size 19))
;;      doom-variable-pitch-font (font-spec :family "Fira Sans") ; inherits `doom-font''s :size
;;      doom-unicode-font (font-spec :family "Input Mono Narrow" :size 12)
;;      doom-big-font (font-spec :family "Fira Mono" :size 19))

(setq-default line-spacing 0.25)
#+end_src

I also gotta activate ~mixed-pitch-set-height~, so that ~mixed-pitch-mode~ actually uses the ~:size~ option from the variable pitch font above.
#+begin_src emacs-lisp :tangle yes
(setq mixed-pitch-set-height t)
#+end_src

Let's bind some keys for quick toggling between the different font modes.
#+begin_src emacs-lisp
(map! :leader
 (:prefix ("t" . "toggle")
       :desc "Mixed pitch mode"       "m"     #'mixed-pitch-mode
       :desc "Variable pitch mode"    "v"     #'variable-pitch-mode
       )
      )
#+end_src
By this, ~visible-mode~ has been unmapped from ~SPC t v~. Let's remap it to ~SPC t V~.
#+begin_src emacs-lisp
(map! :leader
 (:prefix ("t" . "toggle")
       :desc "Visible mode"           "V"     #'visible-mode
       )
      )
#+end_src

** Theme
I like DOOMs default colors
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
#+end_src

But I still wanna customize it a bit.
*** Shades with ewal
I use [[https://github.com/dylanaraps/pywal][pywal]] to have the colors in my terminal fit my wallpaper.
While for Emacs I use the colors from the ~doom-one~ theme, I still want the (transparent) backgrounds of different parts of Emacs to synergyze with pywal.
For this, the [[https://github.com/cyruseuros/ewal][ewal]] package is used to get the colorscheme from pywal into Emacs.

#+begin_src emacs-lisp
(use-package ewal)
(use-package ewal-doom-themes)

(after! doom-themes
        (custom-theme-set-faces! doom-theme
          `(default :background ,(ewal-load-color 'background))
          `(seperator-line :background ,(ewal-load-color 'background))
          `(hl-line :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .1))
          `(org-block :background ,(ewal--color-chshade
                      (ewal-load-color 'background) -0.3))

        ;; Tabs:
        `(tab-bar :background ,(ewal-load-color 'background))
        `(centaur-tabs-selected :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .1))
        `(tab-bar-tab :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .1))
        `(centaur-tabs-unselected :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .05))
        `(tab-bar-tab-inactive :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .05))
        `(tab-line :background ,(ewal-load-color 'background))

        ;; Mode line:
        `(mode-line :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .15))
        `(mode-line-inactive :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .05))
        `(mode-line-emphasis :background ,(ewal--color-chshade
                        (ewal-load-color 'background) .20))

        ;; minibuffer (underneath mode line) and stuff
        `(solaire-default-face :background ,(ewal-load-color 'background))
        ))
#+end_src

** Modeline
Making the modeline a bit taller than the default height (25) seems nice.
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

** Dashboard (startup page)
I the silly banner I found at [[https://github.com/jeetelongname/doom-banners]] for my dashboard. To fit with this, font color is changed to pink.
#+begin_src emacs-lisp
(after! doom-themes
    (custom-theme-set-faces! 'doom-one
        `(doom-dashboard-banner :foreground "pink" :weight bold)
        ))
(setq fancy-splash-image "~/.config/doom/I-am-doom.png")
(setq +doom-dashboard-banner-padding '(0 . 0))
#+end_src
The change in padding is to remove the whitespace after the splash image, so that everything still fits on the screen (for the most part).

** Line Numbers and Wrapping
Display relative line numbers, but do so counting lines as displayed, not actual line breaks in the buffer.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'visual)
#+end_src
This works well for me, because I like overlength lines to always automatically wrap.
#+begin_src emacs-lisp
(global-visual-line-mode t)
#+end_src
Maximum line length (when =window-margin-mode= is active)
#+begin_src emacs-lisp :tangle yes
(setq-default fill-column 100)
#+end_src
** Transparent Background
I like me some transparent backgrounds. This value controls the opacity if transparent background is enabled.
#+begin_src emacs-lisp
(defconst doom-frame-transparency 85)
#+end_src
In contrast, the variable ~doom-frame-opacity~ is used for the current opacity. So this variable is set to ~100~ if transparency is disabled.

Now follows a function to toggle the transparent background on and off.
#+begin_src emacs-lisp
(defun toggle-background-opacity ()
        "toggle transparent background"
        (interactive)
        (if (eq doom-frame-opacity 100)
            (setq doom-frame-opacity doom-frame-transparency)
            (setq doom-frame-opacity 100))
        (set-frame-parameter (selected-frame) 'alpha doom-frame-opacity)
        (add-to-list 'default-frame-alist `(alpha . ,doom-frame-opacity))
        (defun dwc-smart-transparent-frame ()
        (set-frame-parameter
        (selected-frame)
        'alpha (if (frame-parameter (selected-frame) 'fullscreen)
                100
                doom-frame-opacity))))

(map! :leader
 (:prefix ("t" . "toggle")
       :desc "transparency"          "t"     #'toggle-background-opacity
       )
      )
#+end_src

This will make the background transparent at startup.
#+begin_src emacs-lisp
(setq doom-frame-opacity 100)
(toggle-background-opacity)
#+end_src

** Whitespace
Highlight unnecessary or wrong use of whitespace (e.g. mixed tabs and spaces).
#+begin_src emacs-lisp
(use-package! whitespace
  :config (setq whitespace-style '(face empty indentation space-after-tab space-before-tab))
  (global-whitespace-mode +1))
#+end_src
Trailing whitespace doesn't need to be visualized, since it's removed on save anyway.

** Treemacs
By default, the treemacs window is not re-sizable. I don't see why.
#+begin_src emacs-lisp
(setq treemacs-width 30)
(setq treemacs--width-is-locked nil)
(setq treemacs-width-is-initially-locked nil)
#+end_src
Especially when using LaTeX, there's gonna be a lot of files in my directory which I don't actively care about. The following hides these files. (cf. [[https://tecosaur.github.io/emacs-config/config.html#treemacs][tecosaur]])
#+begin_src emacs-lisp :tangle yes
(after! treemacs
  (defvar treemacs-file-ignore-extensions '()
    "File extension which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-globs '()
    "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-regexps '()
    "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
  (defun treemacs-file-ignore-generate-regexps ()
    "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
    (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
  (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
  (defun treemacs-ignore-filter (file full-path)
    "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
    (or (member (file-name-extension file) treemacs-file-ignore-extensions)
        (let ((ignore-file nil))
          (dolist (regexp treemacs-file-ignore-regexps ignore-file)
            (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))

(setq treemacs-file-ignore-extensions
      '(;; LaTeX
        "aux"
        "ptc"
        "fdb_latexmk"
        "fls"
        "synctex.gz"
        "gz" ; the function actually recognizes the last '.', not the first; I don't think I'll ever need to look at .gz-files anyways
        "toc"
        ;; LaTeX - glossary
        "glg"
        "glo"
        "gls"
        "glsdefs"
        "ist"
        "acn"
        "acr"
        "alg"
        ;; LaTeX - pgfplots
        "mw"
        ;; LaTeX - pdfx
        "pdfa.xmpi"
        ;; further LaTeX stuff
        "bbl"
        "bcf"
        "blg"
        "nav"
        "out"
        "snm"
        "vrb"
        ))
(setq treemacs-file-ignore-globs
      '(;; LaTeX
        "*/_minted-*"
        ;; AucTeX
        "*/.auctex-auto"
        "*/_region_.log"
        "*/_region_.tex"))
#+end_src

* Global Functionality
** Local Leader
I'm used to this from my VimTex days.
#+begin_src emacs-lisp
(setq doom-localleader-key ",")
#+end_src
** Move/Cut
I've always liked that the delete command in vim automatically yanks the deleted text, i.e. it acts more like cutting than deleting.
For this reason I've configured 'd' and 'x' to not yank the deleted text, and instead defined 'm' (for "move", because 'c' is already taken) to delete and yank, i.e. cut.

First we clone the default ~evil-delete~ function under the name ~evil-cut~.
#+begin_src emacs-lisp
(setq wrapped-copy (symbol-function 'evil-delete))
(evil-define-operator evil-cut (BEG END TYPE REGISTER YANK-HANDLER)
  "Cut text from BEG to END with TYPE.

Save in REGISTER or in the kill-ring with YANK-HANDLER."
  (interactive "<R><x><y>")
  (funcall wrapped-copy BEG END TYPE REGISTER YANK-HANDLER))
#+end_src

Now we map ~evil-cut~ to 'm'.
#+begin_src emacs-lisp
(map! :n "m" 'evil-cut)
#+end_src

Finally, we automatically redirect all deletions to the black hole register, thus making 'd', 'x', and pasting over something only delete and not copy.
We also need to do it for ~evil-org-delete-char~, since that has different input arguments and an extra ~evil-yank~ in it's definition for some reason.
#+begin_src emacs-lisp
(defun bb/evil-delete (orig-fn beg end &optional type _ &rest args)
  (apply orig-fn beg end type ?_ args))
(advice-add 'evil-delete :around 'bb/evil-delete)
(advice-add 'evil-delete-char :around 'bb/evil-delete)

(defun bb/evil-org-delete-char (orig-fn count beg end &optional type _ &rest args)
  (apply orig-fn count beg end type ?_ args))
(advice-add 'evil-org-delete-char :around 'bb/evil-org-delete-char)
#+end_src

** Auto-complete
Increase time until auto-complete shows up.
#+begin_src emacs-lisp
(setq company-idle-delay 0.4)
#+end_src
** Spell- and grammar checker
These are the dictionaries I want to use for spell checking.
#+begin_src emacs-lisp
(add-hook 'spell-fu-mode-hook
  (lambda ()
    (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "de"))
    (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "en"))
    ))
(setq ispell-personal-dictionary "~/Dropbox/.aspell.en.pws")
#+end_src
Set path to languagetool.
#+begin_src emacs-lisp
(setq langtool-java-classpath "/usr/share/languagetool/*")
#+end_src
** Snippets
This disables the annoying final newline when creating a snippet, which always screws things up.
#+begin_src emacs-lisp
(add-hook 'snippet-mode-hook 'my-snippet-mode-hook)
(defun my-snippet-mode-hook ()
  "Custom behaviours for `snippet-mode'."
  (setq-local require-final-newline nil)
  (setq-local mode-require-final-newline nil))
#+end_src
Also I want to use the Pause key (which I remapped onto my caps lock key) to expand snippets, since I find using tab for both snippets and autocompletion confusing.
#+begin_src emacs-lisp
; first unmap tab for snippets
(map! :map yas-minor-mode-map ; key for snippet expansion
      [tab] nil
      "TAB" nil)
(map! :map yas-keymap ; keys for navigation
      [tab] nil
      "TAB" nil
      [(shift tab)] nil
      [backtab] nil)

; then map pause for snippets instead
(map! :map 'yas-minor-mode-map ; key for snippet expansion
      [pause] #'yas-expand)
(map! :map yas-keymap ; keys for navigation
      [pause] 'yas-next-field-or-maybe-expand
      [(shift pause)] 'yas-prev)
#+end_src
TODO: Snippet expansion is somehow not unmapped from tab yet by this.

Some nicer shortcuts for creating snippets and etc. would also be nice.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("y" . "YASnippet")
       :desc "edit snippet" "e" #'yas-visit-snippet-file
       :desc "insert snippet" "i" #'yas-insert-snippet
       :desc "new snippet" "n" #'+snippets/new
       :desc "find private snippet" "p" #'+snippets/find-private
       )
      )
#+end_src

Hey boy, I heard you like snippets... so I put some snippets in your snippets...
#+begin_src emacs-lisp :tangle yes
(setq yas-triggers-in-field t)
#+end_src
** Zen/Writeroom
#+begin_src emacs-lisp
(map! :leader
 (:prefix ("t" . "toggle")
       :desc "Global writeroom mode"  "W"     #'global-writeroom-mode
       )
      )
#+end_src

* Org Mode
** Org-Paths
#+begin_src emacs-lisp
(setq org-directory "~/org/"
      org-roam-directory "~/Dropbox/roam"
      org-cd-directory (concat org-roam-directory "/tikz-cd")) ; for commutative diagrams
(setq org-agenda-files (list "~/org/todo.org" "~/org/lv_Sommer2023.org"))
#+end_src
** Org Appearance
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis " ▼ "
        ;;org-superstar-headline-bullets-list '("◉" "●" "○" "◆" "●" "○" "◆")
        org-superstar-headline-bullets-list '("❭")
        org-superstar-item-bullet-alist '((?+ . ?✦) (?- . ?➤)) ; changes +/- symbols in item lists
        org-hide-emphasis-markers t     ; do not show e.g. the asterisks when writing something in boldface
        org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil
        org-hidden-keywords '(title)  ; hide #+TITLE:
        org-log-done 'time
        org-agenda-skip-scheduled-if-done t     ; do not show scheduled items in agenda if they're already done
        org-agenda-skip-deadline-if-done t     ; do not show deadlines in agenda if they're already done
        org-deadline-warning-days 7
        org-todo-keywords        ; This overwrites the default Doom org-todo-keywords
          '((sequence
             "TODO(t)"
             "WAIT(w)"
             "TODELEGATE(T)"
             "IDEA(i)"
             "|"
             "DONE(d)"
             "DELEGATED(D)"
             "CANCELLED(c)" ))
        org-todo-keyword-faces
        '(("WAIT" . "#ECBE7B")
        ("TODELEGATE" . "pink")
        ("IDEA" . "cyan")
        ("DONE" . "#5b8c68")
        ("DELEGATED" . "#a9a1e1")
        ("CANCELLED" . "#ff6c6b")
        )
        ))

(custom-set-faces!
  `(org-level-1 :inherit outline-1 :height 1.4)
  `(org-level-2 :inherit outline-2 :height 1.25)
  `(org-level-3 :inherit outline-3 :height 1.1)
  `(org-level-4 :inherit outline-4 :height 1.05)
  `(org-level-5 :inherit outline-5 :height 1.0)
  `(org-document-title :family "K2D" :foreground "#9BDB4D" :background nil :height 2.0)
)
#+end_src

** Org Roam
*** Capture
#+begin_src emacs-lisp :tangle yes
(setq org-roam-capture-templates
      '(("d" "default" plain "%?" :target
            (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+filetags: \n#+title: ${title}\n\n")
        :unnarrowed t)))
#+end_src
Every node should be marked as a draft, until I revisit and refine it (stolen form [[https://jethrokuan.github.io/org-roam-guide/][here]])
#+begin_src emacs-lisp :tangle yes
(defun jethro/tag-new-node-as-draft ()
  (org-roam-tag-add '("draft")))
(add-hook 'org-roam-capture-new-node-hook #'jethro/tag-new-node-as-draft)
#+end_src

Sometimes I want to link notes that are not created yet, but also don't want to be distracted from writing the current note.
This function (taken from [[https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/][SystemCrafters]]) inserts the link without opening the new note in a new buffer. It uses the /first template/ in ~org-roam-capture-templates~ for the new note.
#+begin_src emacs-lisp :tangle yes
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t) ; this is the essential bit
                                                  ))))
    (apply #'org-roam-node-insert args)))
#+end_src

Additionally, I'm getting quite annoyed that links are inserted at the cursor position, not after the cursor position. Even though I guess this is consistent with usual vim functionality, having to press space twice feels weird to me, and binding a new key to have it work similar to "append" ('a' in vim) rather than "insert" ('i' in vim) is a bit unnecessary. So this workaround suits me best. (cf. [[https://github.com/syl20bnr/spacemacs/issues/14137][this issue]])
#+begin_src emacs-lisp :tangle yes
(defadvice org-roam-node-insert (around append-if-in-evil-normal-mode activate compile)
  "If in evil normal mode and cursor is on a whitespace character, then go into
append mode first before inserting the link. This is to put the link after the
space rather than before."
  (let ((is-in-evil-normal-mode (and (bound-and-true-p evil-mode)
                                     (not (bound-and-true-p evil-insert-state-minor-mode))
                                     (looking-at "[[:blank:]]"))))
    (if (not is-in-evil-normal-mode)
        ad-do-it
      (evil-append 0)
      ad-do-it
      (evil-normal-state))))
#+end_src
*** org-roam-ui
One of the killer features associated with org roam are fancy graphs, as e.g. provided by ~org-roam-ui~.
#+begin_src emacs-lisp :tangle yes
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start nil))
#+end_src
*** Tagging links
While org-roam allows for files to be tagged, the links between files cannot. The following adds this functionality. Furthermore, I'm using a [[https://github.com/odomanov/org-roam-ui][fork of org-roam-ui]] which allows filtering these link tags and assigning colors to them (see ~packages.el~). This whole issue is talked about at length in the org-roam discourse (e.g. [[https://org-roam.discourse.group/t/link-categorization/2486/3][here]] and [[https://org-roam.discourse.group/t/add-link-tags-feature/171/34][here]]), but the discussion that this code comes from is [[https://github.com/org-roam/org-roam-ui/discussions/25][here]] (specifically this [[https://gist.github.com/odomanov/ed070a7faf3df1377fccf5d7c5000bf8][gist here]]).

The syntax for these tagged links is
=[[<link id>|:tag <tag> :context <short description>][<link title>]]=.
Beware that this is different from what the author explains in the discussion linked above! It seems to be =:tag=, not =:tags=!

#+begin_src emacs-lisp :tangle yes
;;; org-roam-link-properties.el --- Frobnicate and bifurcate flanges

;; Author: Oleg Domanov <odomanov@yandex.ru>
;; Version: 1.0
;; Keywords: org-roam org-roam-ui

;;; Commentary:

;;;  Org-Roam link properties (for 'id' links only).
;;;  Adapted from https://linevi.ch/en/org-link-extra-attrs.html

;;; Code:

(defun odm/org-link-extra-attrs (orig-fun &rest args)
  "Post processor for parsing links"
  (setq parser-result orig-fun)

  ;;; Retrieving inital values that should be replaced
  (setq raw-path (plist-get (nth 1 parser-result) :raw-link))

  ;; Checking if link match the regular expression
  (if (string-match-p "^id:.*|\s*:" raw-path)
      (progn
	;; Retrieving parameters after the vertical bar
	(setq results (s-split "|" raw-path))
	(setq raw-path (car results))
	(setq path (s-chop-prefix "id:" raw-path))

        ;; Cleaning, splitting and making symbols
        (setq results (s-split "\s" (s-trim (s-collapse-whitespace
                                             (car (-slice results 1))))))
        (setq results (--map (intern it) results))

	;; Updating the ouput with the new values
	(setq orig-fun-cleaned (plist-put (nth 1 orig-fun) :raw-link raw-path))
	(setq orig-fun-cleaned (plist-put orig-fun-cleaned :path path))

        ;; Check that the number is even
        (if (= 2 (length (-last-item (-partition-all 2 results))))
            (list 'link (-snoc orig-fun-cleaned :extra-attrs results))
          (progn
            (message "Links properties are incorrect.")
            (list 'link orig-fun-cleaned))))

    ;; Or returning original value of the function
    orig-fun))

(advice-add 'org-element-link-parser :filter-return #'odm/org-link-extra-attrs)

(defun odm/org-roam-db-extra-properties (link)
  "Append extra-attrs to the LINK's properties."
  (save-excursion
    (goto-char (org-element-property :begin link))
    (let ((path (org-element-property :path link))
          (source (org-roam-id-at-point))
          (extra-attrs (org-element-property :extra-attrs link)))
      (when extra-attrs
        (setq properties (caar (org-roam-db-query
                               [:select properties :from links
                                        :where (= source $s1) :and (= dest $s2)
                                        :limit 1]
                               source path)))
        (setq properties (append properties extra-attrs))
        (when (and source path)
          (org-roam-db-query
           [:update links :set (= properties $s3)
                    :where (= source $s1) :and (= dest $s2)]
           source path properties))))))

(advice-add 'org-roam-db-insert-link :after #'odm/org-roam-db-extra-properties)

(provide 'org-roam-link-properties)

;;; org-roam-link-properties.el ends here
#+end_src

My main use case for this are links tagged with "implication". I use those when one mathematical property implies another. As a simple example, if my roam database had the nodes "rational number" and "real number", then the former should have a link to the latter tagged with "implication", since every rational number is a real number. Then I can filter for links tagged as implications in ~org-roam-ui~ to see how different mathematical structures relate to each other.

To make all this nice to use, let's write a bunch of functions to add and remove link tags. These are mostly based on the function ~org-roam-link-replace-at-point~.
#+begin_src emacs-lisp :tangle yes
(defun org-link-set-tags (&optional tags link)
  "Set the tags of the link at point."
  (interactive)
  (save-excursion
    (save-match-data
      (let* ((tags (or tags (read-string "Tags: ")))
             (link (or link (org-element-context)))
             (raw-link (org-element-property :raw-link link))
             (path (org-element-property :path link))
             (desc (and (org-element-property :contents-begin link)
                        (org-element-property :contents-end link)
                        (buffer-substring-no-properties
                         (org-element-property :contents-begin link)
                         (org-element-property :contents-end link))))
             node)
        (goto-char (org-element-property :begin link))
        (when (org-in-regexp org-link-any-re 1)
          (replace-match (org-link-make-string
                          (concat raw-link "|:tag " tags)
                          (or desc path))))))))

(defun org-link-remove-tags (&optional link)
  "Remove the tags of the link at point."
  (interactive)
  (save-excursion
    (save-match-data
      (let* ((link (or link (org-element-context)))
             (raw-link (org-element-property :raw-link link))
             (path (org-element-property :path link))
             (desc (and (org-element-property :contents-begin link)
                        (org-element-property :contents-end link)
                        (buffer-substring-no-properties
                         (org-element-property :contents-begin link)
                         (org-element-property :contents-end link))))
             node)
        (goto-char (org-element-property :begin link))
        (when (org-in-regexp org-link-any-re 1)
          (replace-match (org-link-make-string
                          raw-link
                          (or desc path))))))))

(defun org-roam-implication-tag ()
  "Tag link at point as implication"
  (interactive)
  (org-link-set-tags "implication")
  )
(defun org-roam-implication-insert ()
  "org-roam-node-insert, but the link is tagged with \"implication\"\n TODO: Does not currently work when a new node is created!"
  (interactive)
  (org-roam-node-insert)
  (org-link-set-tags "implication")
  )
(defun org-roam-implication-insert-immediate ()
  "org-roam-node-insert-immediately, but the link is tagged with \"implication\""
  (interactive)
  (org-roam-node-insert-immediate nil)
  (org-link-set-tags "implication")
  )
#+end_src
*** Commutative Diagrams
I want to use commutative diagrams in some of my roam notes, using the LaTeX-package ~tikz-cd~. However, doing that in LaTeX fragments doesn't work with ~org-roam-ui~ (since that just uses KaTeX, which doesn't support everything in LaTeX). On the other hand, doing it using src-blocks is also not great, cause then the distracting source code is gonna appear both in org and in the UI.

My solution to that is creating a capture template for commutative diagrams (inspired by [[https://github.com/darknmt/org-tikzcd-snippet][this]]). This is done using regular ~org-capture~, since I don't want those files to have IDs and show up in my roam database. This works as follows:
 - Upon running ~org-capture-commutative-diagram~, the user is first prompted for a file name.
 - Afterwards, an org file is created, where the file name is prefixed with a time stamp. The file already contains a ~tikz-cd~ block, and all options necessary for export.
 - Now the user may type the commutative diagram of their dreams.
 - After completing the capture with =C-c C-c=, the diagram will be rendered to a png image by LaTeX/imagemagick. After this is finished, the capture buffer closes, and a link to the image is inserted in the previously opened buffer.

For the actual capture template: The code is passed both through ~format~ and through ~org-capture~, which necessitates double escaping quotations and backspaces. This makes it super hard to read, so I suggest you just try it out if you wanna see what it does. ^^ The ~%%~ is a masked percentage sign btw.
Also there are checks in place to make sure the functions place in ~org-capture~-hooks are only run when actually creating a commutative diagram (cf. [[https://emacs.stackexchange.com/a/48567][stackexchange]]).
#+begin_src emacs-lisp :tangle yes
(defun commutative-diagram-filename-generate ()
  (setq commutative-diagram-filename--name (read-string "Name: "))
  (setq commutative-diagram-filename--time (format-time-string "%Y%m%d%H%M%S"))
  (setq commutative-diagram-filename--image (expand-file-name (format "%s-%s.png" commutative-diagram-filename--time commutative-diagram-filename--name) org-cd-directory))
  (setq commutative-diagram-filename--org (expand-file-name (format "%s-%s.org" commutative-diagram-filename--time commutative-diagram-filename--name) org-cd-directory)))

(after! org-capture (add-to-list 'org-capture-templates
  '("c" "Commutative Diagram" plain
     (file commutative-diagram-filename-generate)
     "%(format \"#+TITLE: %s\n#+STAMP: %s\n#+HEADER: :imagemagick yes :iminoptions -density 600 -geometry 1500 :buffer no :fit yes \n#+HEADER: :results raw  :file %s-%s.png \n#+HEADER: :packages '((\\\"\\\" \\\"tikz-cd\\\")) \n#+HEADER: :exports results :results output graphics file \n#+BEGIN_SRC latex \n\\\\begin{tikzcd}[white]\n %%? \n\\\\end{tikzcd}\n#+END_SRC\" commutative-diagram-filename--name commutative-diagram-filename--time commutative-diagram-filename--time commutative-diagram-filename--name)")))

(defun org-capture-commutative-diagram--render ()
    (when (and (not org-note-abort) (equal (plist-get org-capture-plist :key) "c")) ; execute only for the commutative diagram capture template
    (org-babel-execute-buffer)))
(after! org-capture (add-hook 'org-capture-before-finalize-hook 'org-capture-commutative-diagram--render))

(defun org-capture-commutative-diagram--insert-link () (interactive)
  (when (and (not org-note-abort) (equal (plist-get org-capture-plist :key) "c")) ; execute only for the commutative diagram capture template
    (evil-open-below 1)
    (insert "[[" commutative-diagram-filename--image "]]\n")
    (evil-normal-state)
    (org-redisplay-inline-images)
))
(after! org-capture (add-hook 'org-capture-after-finalize-hook 'org-capture-commutative-diagram--insert-link))

(defun org-capture-commutative-diagram () (interactive)
    (org-capture nil "c")
)
#+end_src
*** Keybindings
Basically taking the default keybindings and moving them to ~SPC r~, which was still free.
Only change is that I'm using ~org-roam-ui~ for the graph.
#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix ("r" . "roam")
         :desc "Open random node"           "0" #'org-roam-node-random
         :desc "Find node"                  "f" #'org-roam-node-find
         :desc "Find ref"                   "F" #'org-roam-ref-find
         :desc "Show UI"                    "g" #'org-roam-ui-open
         :desc "Insert node"                "i" #'org-roam-node-insert
         :desc "Insert node immediately"    "I" #'org-roam-node-insert-immediate
         :desc "Insert imp. immediately"    "j" #'org-roam-implication-insert-immediate
         :desc "Tag link as implication"    "J" #'org-roam-implication-tag
         :desc "Capture to node"            "n" #'org-roam-capture
         :desc "Toggle roam buffer"         "r" #'org-roam-buffer-toggle
         :desc "Launch roam buffer"         "R" #'org-roam-buffer-display-dedicated
         :desc "Sync database"              "s" #'org-roam-db-sync
         :desc "Add tag"                    "t" #'org-roam-tag-add
         :desc "Remove tag"                 "T" #'org-roam-tag-remove
         :desc "Set link tags"              "l" #'org-link-set-tags
         :desc "Remove link tags"           "L" #'org-link-remove-tags
         :desc "Add alias"                  "a" #'org-roam-alias-add
         :desc "Remove alias"               "A" #'org-roam-alias-remove
         :desc "Commutative diagram"        "c" #'org-capture-commutative-diagram
         (:prefix ("d" . "by date")
          :desc "Goto previous note"        "b" #'org-roam-dailies-goto-previous-note
          :desc "Goto date"                 "d" #'org-roam-dailies-goto-date
          :desc "Capture date"              "D" #'org-roam-dailies-capture-date
          :desc "Goto next note"            "f" #'org-roam-dailies-goto-next-note
          :desc "Goto tomorrow"             "m" #'org-roam-dailies-goto-tomorrow
          :desc "Capture tomorrow"          "M" #'org-roam-dailies-capture-tomorrow
          :desc "Capture today"             "n" #'org-roam-dailies-capture-today
          :desc "Goto today"                "t" #'org-roam-dailies-goto-today
          :desc "Capture today"             "T" #'org-roam-dailies-capture-today
          :desc "Goto yesterday"            "y" #'org-roam-dailies-goto-yesterday
          :desc "Capture yesterday"         "Y" #'org-roam-dailies-capture-yesterday
          :desc "Find directory"            "-" #'org-roam-dailies-find-directory)))
#+end_src

Then additionally, I want quick control over the UI from the local leader.
#+begin_src emacs-lisp
(map! :after org
    :map org-mode-map
    :localleader
    :prefix ("u" . "org-roam-ui")
    "o" #'org-roam-ui-open
    "z" #'org-roam-ui-node-zoom
    "l" #'org-roam-ui-node-local
    "T" #'org-roam-ui-sync-theme
    "f" #'org-roam-ui-follow-mode
    "a" #'org-roam-ui-add-to-local-graph
    "c" #'org-roam-ui-change-local-graph
    "r" #'org-roam-ui-remove-from-local-graph)
#+end_src
*** Appearance
I want org roam notes to have special appearance. This function only turns on specific settings for org-files in ~org-roam-directory~.
#+begin_src emacs-lisp :tangle yes
(defun roam-pseudohook ()
  (cond ((string-prefix-p org-roam-directory (buffer-file-name))
         (window-margin-mode 1)
         (mixed-pitch-mode 1)
         )))
(after! org (add-hook 'org-mode-hook 'roam-pseudohook))
#+end_src
Writeroom mode isn't a great idea during capture buffers. Let's add a hook to ~org-capture-mode~ to disable it.
#+begin_src emacs-lisp :tangle yes
(defun writeroom-mode-deactivate () (writeroom-mode -1))
(add-hook 'org-roam-capture-new-node-hook 'writeroom-mode-deactivate)
(add-hook 'org-capture-mode-hook 'writeroom-mode-deactivate)
#+end_src
I want to see my tags when searching for notes.
#+begin_src emacs-lisp :tangle yes
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:30}" 'face 'org-tag))) ; 30 is the max. number of characters allocated for tags
#+end_src
** LaTeX & Org
*** Preamble
Preamble used for LaTeX fragments in org:
#+begin_src emacs-lisp :tangle yes
(after! org (setq org-format-latex-header (concat org-format-latex-header
    "\\usepackage{tikz, pgfplots}\\pgfplotsset{compat=1.16}\\usetikzlibrary{cd}")))
#+end_src
*** Settings necessary for TikZ
There is two ways of rendering inline LaTeX previews: ~dvipng~ and ~imagemagick~.
TikZ (and in particular ~tikzcd~) don't like ~dvipng~ somehow. So let's switch over to the magicks:
#+begin_src emacs-lisp :tangle yes
(after! org (setq org-latex-create-formula-image-program 'imagemagick))
#+end_src
For this to work however, ~imagemagick~ needs some further customization outside of Emacs (see [[https://stackoverflow.com/a/59193253][here]]).
*** Automatic Rendering
As long as it doesn't cause me performance issues, I will enable automatic rendering of LaTeX-previews.
The ~org-fragtog~ package then enables automatically switching between LaTeX-preview and its underlying code.
#+begin_src emacs-lisp :tangle yes
(after! org (setq org-startup-with-latex-preview t))
(use-package! org-fragtog
    :after org
    :hook (org-mode . org-fragtog-mode) ; this auto-enables it when you enter an org-buffer
    :config
)
#+end_src
*** Correct Backgrounds
The following makes sure the backgrounds of LaTeX fragments (or their surroundings) don't look bad (cf. [[https://tecosaur.github.io/emacs-config/config.html#prettier-highlighting][tecosaur]])
#+begin_src emacs-lisp :tangle yes
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src
*** Automatically Update Size
The size of LaTeX fragments does not automatically update when the font size is changed. This fixes that.
It turned out to not be so easy though for an elisp noob like me, so here are some notes:
 - Annoyingly, disabling LaTeX previews is achieved by running ~org-latex-preview~ with /prefix argument/, i.e. by pressing ~C-u~ before running the function. Calling this from a script is a bit of a hassle. This is what happens in ~org-latex-preview-clear~.
 - I want to check whether writeroom-mode is active. This is done by checking the ~writeroom-mode~ variable. However, this variable is at the same time the function that toggles the mode. So ~bound-and-true-p~ is used to only check the variable and not call the function. (analogously for big-font-mode)
#+begin_src emacs-lisp :tangle yes
(setq org-latex-default-scale 1.5)
(setq org-latex-writeroom-scale 2.5)
(setq org-latex-big-font-scale 2.5)

(defun org-latex-preview-clear ()
  "Disable org-latex-preview (which is the same as running org-latex-preview with prefix argument)"
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively 'org-latex-preview)))

(defun latex-preview-rescale ()
  (cond ((bound-and-true-p writeroom-mode) (setq org-format-latex-options (plist-put org-format-latex-options :scale org-latex-writeroom-scale)))
        ((bound-and-true-p doom-big-font-mode) (setq org-format-latex-options (plist-put org-format-latex-options :scale org-latex-big-font-scale)))
        (t (setq org-format-latex-options (plist-put org-format-latex-options :scale org-latex-default-scale)))
    )
  ;; re-render LaTeX fragments
  (org-latex-preview-clear)
  (org-latex-preview)
  )
(add-hook 'writeroom-mode-hook 'latex-preview-rescale)
(add-hook 'doom-big-font-mode-hook 'latex-preview-rescale)
#+end_src
*** Smartparens
I want Smartparens to also recognize typical LaTeX-patterns in org-mode (cf. [[https://emacs.stackexchange.com/a/56094][stackexchange]]).
#+begin_src emacs-lisp :tangle yes
(require 'smartparens-config)
  (sp-local-pair 'org-mode "\\[" "\\]")
  (sp-local-pair 'org-mode "$" "$")
  (sp-local-pair 'org-mode "'" "'" :actions '(rem))
  (sp-local-pair 'org-mode "=" "=" :actions '(rem))
  (sp-local-pair 'org-mode "\\left(" "\\right)" :trigger "\\l(" :post-handlers '(sp-latex-insert-spaces-inside-pair))
  (sp-local-pair 'org-mode "\\left[" "\\right]" :trigger "\\l[" :post-handlers '(sp-latex-insert-spaces-inside-pair))
  (sp-local-pair 'org-mode "\\left\\{" "\\right\\}" :trigger "\\l{" :post-handlers '(sp-latex-insert-spaces-inside-pair))
  (sp-local-pair 'org-mode "\\left|" "\\right|" :trigger "\\l|" :post-handlers '(sp-latex-insert-spaces-inside-pair))
#+end_src
** Xournal++ integration ("Org Notebook")
I take handwritten notes using [[https://github.com/xournalpp/xournalpp][Xournal++]]. Being able to integrate those into org files sounds great, especially for hand-drawn diagrams.
There exists a package for this called [[https://gitlab.com/vherrmann/org-xournalpp][org-xournalpp]], but the following [[https://www.reddit.com/r/orgmode/comments/egasgy/comment/fc5molm/][code snippet I found on reddit]] works better for my use case. Why? Because it directly links images into the org document, which also works with ~org-roam-ui~.
I modified the snippet slightly to also work in files without headings, work with a template, and export with transparent background.
#+begin_src emacs-lisp :tangle yes
;; Org Notebook
(setq org-notebook-result-dir "./handwritten/")
(setq org-notebook-template-path "~/Dropbox/template.xopp")

(defun org-notebook-get-png-link-at-point (shouldThrowError)
    "Returns filepath of org link at cursor"
    (setq linestr (thing-at-point 'line))
    (setq start (string-match "\\[\\[" linestr))
    (setq end (string-match "\\]\\]" linestr))
    (if shouldThrowError (if start nil (error "No link found")) nil)
    (if shouldThrowError (if end nil   (error "No link found")) nil)
    (if shouldThrowError (if (string-match ".png" linestr) nil   (error "Link is not an image")) nil)

    (if (and linestr start end) (substring linestr (+ start 2) end) nil)
)

(defun org-notebook-gen-filename-at-point ()
    "Returns a list of valid file paths corresponding to current context(Header & Date)."

    (unless (file-directory-p org-notebook-result-dir) (make-directory org-notebook-result-dir))

    (setq date-string (format-time-string "%Y-%m-%d_%H%M%S"))

    ; return current heading if available
    ; otherwise return title of org document
    ; if that's also not available, return nil
    (setq heading (condition-case nil
            (nth 4 (org-heading-components))
            (error (if (org-collect-keywords '("TITLE"))
                (nth 1 (nth 0 (org-collect-keywords '("TITLE"))))
                ""
            ))))


    (setq heading (replace-regexp-in-string "\\[.*\\]" "" heading))

    ;; First filter out weird symbols
    (setq heading (replace-regexp-in-string "[/;:'\"\(\)]+" "" heading))
    (setq heading (string-trim heading))
    ;; filter out swedish characters åäö -> aao
    (setq heading(replace-regexp-in-string "[åÅäÄ]+" "a" heading))
    (setq heading(replace-regexp-in-string "[öÓ]+" "o" heading))
    ;; whitespace and . to underscores
    (setq heading (replace-regexp-in-string "[ .]+" "_" heading))

    (setq filename (format "%s-%s" heading date-string))
    (setq filename (read-minibuffer "Filename: " filename))

    (setq image-path (format "%s%s.png" org-notebook-result-dir filename))
    (setq xournal-path (format "%s%s.xopp" org-notebook-result-dir filename))

    (list image-path xournal-path)
)


(defun org-notebook-create-xournal ()
    "Insert an image and open the drawing program"
    (interactive)

    (setq notebookfile (org-notebook-gen-filename-at-point))
    (setq image-path (car notebookfile))
    (setq xournal-path (nth 1 notebookfile))

    (evil-open-below 1)
    (insert "[[" image-path "]]\n")
    (evil-normal-state)

    (start-process-shell-command "org-notebook-copy-template" nil (concat "cp " org-notebook-template-path " " xournal-path))
    (start-process "org-notebook-drawing" nil "xournalpp" xournal-path)
)

(defun org-notebook-edit-xournal ()
    (interactive)
    (setq image-path (org-notebook-get-png-link-at-point nil))
    (if (not image-path)
        (if (y-or-n-p "No matching xournal file, create one?")
            (org-notebook-create-xournal)
            (error "Nothing more to do...")
            )
            nil
        )

    (setq xournal-path (replace-regexp-in-string "\.png" ".xopp" image-path))
    (if (file-readable-p xournal-path) (start-process "org-notebook-drawing" nil "xournalpp" xournal-path) (error "No matching xournal file found"))
)

(defun org-notebook-generate-xournal-image ()
    (interactive)
    (setq image-path (org-notebook-get-png-link-at-point t))
    (setq xournal-path (replace-regexp-in-string "\.png" ".xopp" image-path))
    (if (file-readable-p xournal-path) nil (error "No matching xournal file found"))

    (setq xournal_cmd (format "xournalpp --export-no-background %s %s %s" xournal-path "-i" image-path))
    (print (format "Generating image file: %s" xournal_cmd))
    (shell-command xournal_cmd)


    (setq convert_cmd (format "convert %s -trim -bordercolor none -border 20 +repage %s" image-path image-path))
    (print (format "Auto cropping image: %s" convert_cmd))
    (shell-command convert_cmd)

    (org-redisplay-inline-images)
)


(map! :after org
    :map org-mode-map
    :localleader
    :prefix ("x" . "Xournal")
    "x" #'org-notebook-create-xournal
    "g" #'org-notebook-generate-xournal-image
    "e" #'org-notebook-edit-xournal)
#+end_src
** org-d20
Org mode is really nice for tabletop RPGs, both taking notes as a player, as well as for writing your campaign as a game master.
The [[https://github.com/spwhitton/org-d20][org-d20]] minor mode allows for rolling dice and taking care of combat initiative and hp within org.

#+begin_src emacs-lisp
(map! :localleader
      :map org-mode-map
      (:prefix ("D" . "org-d20")
       :desc "start/advance combat" "i" #'org-d20-initiative-dwim
       :desc "add to combat" "a" #'org-d20-initiative-add
       :desc "apply damage at point" "d" #'org-d20-damage
       :desc "roll" "r" #'org-d20-roll
       )
      )
#+end_src
* LaTeX
** "Fixing" defaults
There are a couple of things that I, a person who learned LaTeX long before emacs, find quite annoying in how Doom is setup do deal with LaTeX by default.
These changes make everything feel more intuitive to me.
#+begin_src emacs-lisp
;;(setq +latex-viewers nil)
(setq +latex-indent-item-continuation-offset 'auto)
(setq evil-tex-toggle-override-m nil) ;; I want to use m for "move" (evil-cut)
;;... so I map toggle keybindings to localleader instead
(map! :localleader
      :map evil-tex-mode-map
      (:prefix ("t" . "toggle") ;; TODO this is not displaying descriptions properly, probably related to https://github.com/hlissner/doom-emacs/issues/4288
       :desc "command"          "c"     #'evil-tex-toggle-command
       :desc "delimiter"        "d"     #'evil-tex-toggle-delim
       :desc "environment"      "e"     #'evil-tex-toggle-env
       :desc "math"             "m"     #'evil-tex-toggle-math
       :desc "math align*"      "M"     #'evil-tex-toggle-math-align
       :desc "section"          "S"     #'evil-tex-toggle-section
       )
      )
;;
#+end_src

The following turns of all flycheck-warnings in AUCTex, since for the most part I just find them annoying.
#+begin_src emacs-lisp
(setq flycheck-global-modes '(not LaTeX-mode latex-mode))
#+end_src

Unfortunately rainbow delimiters break frequently in LaTeX (because of "mismatched" delimiters in open intervals like $]a,b[$, but also randomly at other times). Best to disable them.
#+begin_src emacs-lisp
(add-hook 'TeX-mode-hook 'rainbow-delimiters-mode-disable
          'LaTeX-mode-hook 'rainbow-delimiters-mode-disable)
(after! latex
  (remove-hook 'TeX-update-style-hook #'rainbow-delimiters-mode))
#+end_src

Better shortcut for showing TeX-errors (backtick is very annoying on a German keyboard).
#+begin_src emacs-lisp
(map! :localleader
      :map evil-tex-mode-map
      :desc "TeX-next-error"
      "e" #'TeX-next-error)
#+end_src

Another annoyance: I don't like it when AUCTex interferes with my quotation marks.
Removing this AUCTex-feature is reasonably simple and can either be done through the ~TeX-quote-after-quote~-variable, or by just un-mapping ~TeX-insert-quote~ from the quotation mark key.
However, for whatever reason this same feature was also implemented in ~smartparens~, specifically ~smartparens-latex.el~. And removing this is /really/ a nightmare. None of the solutions I found online worked for me (see [[https://github.com/doomemacs/doomemacs/issues/1688][here]], [[https://github.com/doomemacs/doomemacs/issues/485][here]], [[https://github.com/Fuco1/smartparens/issues/1100][here]], [[https://emacs.stackexchange.com/questions/34035/how-to-make-smartparens-insert-and-instead-of-in-latex-modes][here]], [[https://emacs.stackexchange.com/questions/31166/smartparens-not-insert-pair-of-latex-quotes?rq=1][here]], [[https://github.com/Fuco1/smartparens/issues/983][here]], and [[https://emacs.stackexchange.com/questions/52233/disable-tex-modes-auto-tex-insert-quote-functionaliy][here]]...).
So instead, after like 3 hours of trial and error, I'm settling for this hack.
#+begin_src emacs-lisp :tangle yes
(setq TeX-quote-after-quote t) ; how this is supposed to work, for good measure

(defun insert-standard-quote ()
        "insert a completely normal quotation mark, bypassing weird AUCTex-defaults"
        (interactive)
        (insert "\""))
(map! :after tex
      :map tex-mode-map
      "\"" 'insert-standard-quote)
(map! :after tex
      :map LaTeX-mode-map
      "\"" 'insert-standard-quote)
#+end_src
** Appearance
Long lines are hard to read. This activates a maximum line length in TeX-buffers.
#+begin_src emacs-lisp :tangle yes
(add-hook 'TeX-mode-hook 'window-margin-mode)
#+end_src
** CDLaTeX
This mode provides pretty useful shortcuts for writing math. I ignored this package for too long, probably cause the default keybindings really don't work with me.
#+begin_src emacs-lisp :tangle yes
(map! :after latex :map cdlatex-mode-map
      ; I'm too used to using the ' key to type stuff like "f prime"
      "\'"      nil
      ; so this key is better imo
      "\´"       #'cdlatex-math-modify
      "\`"       #'cdlatex-math-symbol
      )
(map! :map org-cdlatex-mode-map     ; same thing for within org mode
      "\'"      nil
      "\´"       #'cdlatex-math-modify
      "\`"       #'cdlatex-math-symbol
      )
#+end_src
The internal variables also need to be changed, or otherwise the old keys will still be active in the CDLaTeX menu.
#+begin_src emacs-lisp :tangle yes
(require 'cdlatex)
(setq cdlatex-math-modify-prefix 180)
(setq cdlatex-math-symbol-prefix 96)
#+end_src

Let's also add a few more symbols/modifiers. (cf. [[https://tecosaur.github.io/emacs-config/config.html#math-input-cdlatex][tecosaur]])
#+begin_src emacs-lisp :tangle yes
(after! cdlatex
  (setq cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow" "" "\\inf"))
     (?2    ("^2" "\\sqrt{?}" ""))
     (?3    ("^3" "\\sqrt[3]{?}" ""))
     (?^    ("\\uparrow" "" "\\sup"))
     (?k    ("\\kappa" "" "\\ker"))
     (?m    ("\\mu" "" "\\lim"))
     (?c    (""   "\\circ" "\\cos"))
     (?d    ("\\delta" "\\partial" ""))
     (?D    ("\\Delta" "\\nabla" "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot" "\\dots"))
     (?:    ("\\vdots" "\\ddots"))
     (?*    ("\\times" "\\star" "\\ast")))
   cdlatex-math-modify-alist
   '((?B    "\\mathbb"        nil          t    nil  nil)
     (?o    "\\operatorname"  nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+end_src


* Tangle this file!

Tangle on save? Reload after tangle? These hooks will ask you after every save.
(Taken from https://github.com/joseph8th/literatemacs and modified for DOOM)

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Reload?")(doom/reload))) nil t)
;; eval: (add-hook 'after-save-hook (lambda ()(if (y-or-n-p "Tangle?")(org-babel-tangle))) nil t)
;; End:
